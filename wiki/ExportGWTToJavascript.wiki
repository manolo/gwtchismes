Exportando librerias desarrolladas en GWT a javascript.

= Introducción =
Hay numerosas ventajas en usar GWT para desarrollar codigo javascript de calidad, especialmente que el programador no tiene que ser un experto en javascript, conocer particularidaded de cada navegador, empaquetamiento, ofuscación, dependencias, etc.

Para mi, la relación que existe entre GWT y javascript, es la misma que entre el lenguaje C y ensamblador. Para qué voy a programar en un lenguaje de bajo nivel con caracteristicas distintas para cada plataforma si se puede trabajar en un lenguaje de alto nivel, y dejar al compilador que corrija errores, compile, enlace, optimice, ofusque, y genere el código mas apropiado para cada plataforma.
Además, al igual que en C se puede usar ensamblador 'inline', en GWT podemos introducir codigo javascript en nuestro codigo java utilizando [http://code.google.com/webtoolkit/doc/1.6/DevGuideCodingBasics.html#DevGuideJavaScriptNativeInterface JSNI]. 

= Detalles =
 * ¿porqué el código que genera GWT no es usable desde javascript nativo?. Básicamente porque la optimizacion de GWT renombra clases, variables, métodos, descarta todo el codigo innecesario, genera nuevas clases, metodos, etc. En pocas palabras, el codigo js producido se comporta justamente como queremos, pero no se corresponde con el diseño que tenemos en nuestra aplicacion java, y ademas es distinto para cada navegador.

 * Entonces, ¿cómo se pueden hacer llamadas desde javascript a codigo generado por GWT?. Se consigue introduciendo llamadas nativas a javascript que guarden referencias a nuestro codigo javascript en el objeto window del navegador. Para ello, en el codigo javascript debemo utilizar etiquetas especiales que el compilador actualiza con el nombre final de nuestro mñetodo compilado y ofuscado.
{{{
 package jschismes.client;
 public class HelloClass implements EntryPoint{
    String prefix = "Hello: ";
    public void onModuleLoad() {
        exportHelloMethod();
    }
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
    private native void exportHelloMethod() /*-{
      $wnd.hello: function(param1, param2) {
         return this.@jschismes.client.HelloClass::helloMethod(Ljava/lang/String;) (name);
      };
    }-*/;
 }
}}}
{{{
  <script language='javascript'>
    window.hello("Manolo");
  </script>
}}}

 * ¿Qué podemos hacer para simplificar este proceso?. Sencillo, usar la libreria gwt-exporter. Con ella y haciendo anotaciones en nuestro código java, el compilador es el que genera todo el codigo para publicar nuestros atributos en el objeto window.

= Usando gwt-exporter =
 # Sólo las clases anotadas como @Export y que implementan 'Exportable' seran procesadas, y sólo sus métodos públicos estaran disponibles. Por defecto gwt-exporter pondrá nuestras clases en el objeto window bajo el name-space de nuestra aplicación, en nuestro caso seria window.jschismes.client, pero se puede modificar usando la anotación @Exportpackage.
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public void show(){
  }
}
}}}
 # Las clases heredadas, y sus métodos públicos no se exportan a no ser que se anoten especificamente. Aun así será necesario que implementen el interfaz 'Exportable'
{{{
package gwtchismes.client;
public class GWTCDatePickerAbstract implements Exportable {
  @Export
  public void foo(){
  }
}
}}}
 # En el entry-point de nuestra aplicación es necesario notificar a GWT qué clases queremos exportar en esta aplicación. Y debido a desconocemos cuándo la aplicación GWT estará disponible, es conveniente configurar una llamada al metodo javascript nativo que usa nuestra librería.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(DatePicker.class)).export();
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;
}
}}}
{{{
  <script language='javascript'>
    function jscOnLoad() {
        var picker = new jsc.DatePicker({
        });
        picker.show();
    }
  </script>
}}}
 # Los argumentos y retornos de funcion deben utilizar tipos basicos u Objetos que se han definido como Exportable, de los cuales sólo estarán disponibles los metodos públicos.
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public String show(boolean a1, char a2, int a3, long a3, double a3){
  }
}
}}}

 # Para objetos que estan implementados tanto en Javascript como en GWT, como es el caso de Date, será necesario implementar 'JSNI bridges' que utilicen la clase JavaScriptObject y tipos primitivos. 
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  Date currentDate = new Date();
  public JavaScriptObject getCurrentDate(){
     return timeToJsObject(currentDate.getTime());
  }
  public void setCurrentDate(JavaScriptObject date){
     currentDate = new Date(jsObjectToTime(date));
  }

  private static native JavaScriptObject timeToJsObject(double time) /*-{
    return new Date(time);
  }-*/;
  private static native double jsObjectToTime(JavaScriptObject d) /*-{
    return (d && d.getTime) ? d.getTime(): 0;
  }-*/;
}
}}}
{{{
  <script language='javascript'>
    function jscOnLoad() {
        var picker = new jsc.DatePicker();
        picker.setCurrentDate(new Date());
        window.alert(picker.getCurrentDate());
    }
  </script>
}}}

 # Otra cosa interesante para tener una libreria que se comporte de una manera tradicional será útil implementar constructores de nuestros objetos que acepten como argumento objetos de propiedades javascript. Esto se consigue creando una clase que sirva de puente entre estos atributos javascript y GWT:
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  Date selectedDate = new Date();
  int type = 0;
  public DatePicker(JavaScriptObject prop) {

    JsProperties jsProp = new JsProperties(prop);

    this.type = jsProp.getInt("type");
    this.selectedDate = jsProp.getDate("selectedDate");
  });

}
}}}

{{{
package jschismes.client;

public class JsProperties {

  JavaScriptObject p = null;

  JsProperties(JavaScriptObject p) {
    this.p = p;
  }

  public String get(String name) {
    return getImpl(p, name, "");
  }

  private static native String getImpl(JavaScriptObject p, String name) /*-{
    return p[name] ? p[name].toString() : p[name] === false ? "false" : null;
  }-*/;

  public int getInt(String name) {
    String val = get(name);
    return val == null ? null : Integer.valueOf(val);
  }

}

}}}


