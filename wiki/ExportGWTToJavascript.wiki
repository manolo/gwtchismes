Exportando librerias desarrolladas en GWT a javascript.

= Introducción =
Hay numerosas ventajas en usar GWT para desarrollar codigo javascript de calidad, especialmente que el programador no tiene que ser un experto en javascript, conocer particularidaded de cada navegador, empaquetamiento, ofuscación, dependencias, etc.

Comparando, la relación que existe entre GWT y javascript, es la misma que entre el lenguaje C y código ensamblador. Para qué voy a programar en un lenguaje de bajo nivel con caracteristicas distintas para cada plataforma si se puede trabajar en un lenguaje de alto nivel, y dejar al compilador que corrija errores, compile, enlace, optimice, ofusque, y genere el código mas apropiado para cada plataforma.
Además, al igual que en C se puede usar ensamblador 'inline', en GWT podemos introducir código javascript en nuestro código java utilizando [http://code.google.com/webtoolkit/doc/1.6/DevGuideCodingBasics.html#DevGuideJavaScriptNativeInterface JSNI]. 

= Detalles =
 * ¿porqué el código que genera GWT no es usable desde javascript nativo?. Básicamente porque en el proceso de compilado,  GWT renombra clases, variables, métodos, descarta todo el codigo innecesario, genera nuevas clases, metodos, etc. En pocas palabras, el codigo js producido se comporta justamente como queremos, pero no se corresponde con el diseño que tenemos en nuestra aplicacion java, ademas es distinto para cada navegador y es ilegible.

 * Entonces, ¿cómo se pueden hacer llamadas desde javascript a codigo generado por GWT?. Se consigue guardando referencias a nuestro codigo javascript en el objeto window del navegador. Para ello, en el código javascript del método nativo que guarda esta referencia, debemos utilizar etiquetas especiales que el compilador actualiza con el nombre final de nuestro método compilado.
{{{
 package jschismes.client;
 public class HelloClass implements EntryPoint{
    String prefix = "Hello: ";
    public void onModuleLoad() {
        // Al cargar la aplicacion, exportamos el metodo
        exportHelloMethod();
    }
    
    // Metodo que queremos usar desde javascript
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
    
    // Solo se usa para crear una referencia a nuestra funcion en el navegador
    private native void exportHelloMethod() /*-{
      $wnd.hello: function(param1, param2) {
         return this.@jschismes.client.HelloClass::helloMethod(Ljava/lang/String;) (name);
      };
    }-*/;
 }
}}}
 Codigo HTML
{{{
  <script language='javascript'>
    window.hello("Manolo");
  </script>
}}}

 * ¿Qué podemos hacer para simplificar este proceso?. Sencillo, usar la libreria [http://code.google.com/p/gwt-exporter/ gwt-exporter]. Con ella y haciendo anotaciones en nuestro código java, el compilador es el que genera todo el codigo para publicar nuestros atributos en el objeto window.
{{{
 package jschismes.client;
 @Export
 public class HelloClass implements Exportable {
    String prefix = "Hello: ";
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
 }
}}}
 Código HTML
{{{
  <script language='javascript'>
    var hello = new jschismes.client.HelloClass();
    hello.helloMethod("Manuel");
    window.hello("Manolo");
  </script>
}}}

= Usando gwt-exporter =
 # Sólo las clases anotadas como @Export y que implementan 'Exportable' seran procesadas, y sólo sus métodos públicos estaran disponibles. Por defecto gwt-exporter pondrá nuestras clases en el objeto window bajo el name-space del paquete de nuestra aplicación, en nuestro caso seria window.jschismes.client, pero se puede modificar usando la anotación @Exportpackage.
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public void show(){
  }
}
}}}
 # Las clases heredadas, y sus métodos públicos no se exportan a no ser que se anoten especificamente. Aun así será necesario que implementen el interfaz 'Exportable'
{{{
package gwtchismes.client;
public class GWTCDatePickerAbstract implements Exportable {
  @Export
  public void foo(){
  }
}
}}}
 # En el punto de entrada de nuestra aplicación será necesario notificar a GWT qué clases queremos exportar.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(DatePicker.class)).export();
  }
}
}}}
 # También en este punto de entrada, y debido a que nuestra libreria tarda un tiempo en estar disponible, es conveniente hacer una llamada a un metodo javascript que la use.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;
}
}}}
{{{
  <script language='javascript'>
    function jscOnLoad() {
        var picker = new jsc.DatePicker();
        picker.show();
    }
  </script>
}}}
 # Los argumentos y retornos de funcion deben utilizar tipos primitivos u Objetos que se hayan anotado como  @Export.
{{{
@Export
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public String show(boolean a1, char a2, int a3, long a4, double a5, myClass a6){
  }
}
}}}
{{{
@Export
public class myClass implements Exportable {
}
}}}

 # Hay objetos que pueden estar implementados tanto en Javascript como en GWT, para ellos será necesario desarrollar 'JSNI bridges' usando la clase JavaScriptObject. Un claro ejemplo es el objeto Date que tiene distinta implementación aunque un comportamiento similar.
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  Date currentDate = new Date();
  public JavaScriptObject getCurrentDate(){
     return timeToJsObject(currentDate.getTime());
  }
  public void setCurrentDate(JavaScriptObject date){
     currentDate = new Date(jsObjectToTime(date));
  }

  private static native JavaScriptObject timeToJsObject(double time) /*-{
    return new Date(time);
  }-*/;
  private static native double jsObjectToTime(JavaScriptObject d) /*-{
    return (d && d.getTime) ? d.getTime(): 0;
  }-*/;
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.setCurrentDate(new Date());
     window.alert(picker.getCurrentDate());
  </script>
}}}

 # Los constructores de objetos en javascript generalmente aceptan un objeto de tipo 'javascript properties'. Por tanto será interesante que nuestros objetos exportados tengan un constructor que aceptando un objeto javascript sea capaz de extraer la configuración que el usuario quiere. Esto se consigue creando una clase que sirva de puente entre estos atributos javascript y GWT.
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  Date selectedDate = new Date();
  int type = 0;
  public DatePicker(JavaScriptObject prop) {

    JsProperties jsProp = new JsProperties(prop);

    this.type = jsProp.getInt("type");
    this.selectedDate = jsProp.getDate("selectedDate");
  });

}
}}}
Un ejemplo más completo de esta clase la puedes obtener de [
http://code.google.com/p/gwtupload/source/browse/trunk/GWTUpload/src/jsupload/client/JsProperties.java aquí]
{{{
package jschismes.client;

public class JsProperties {

  JavaScriptObject p = null;

  JsProperties(JavaScriptObject p) {
    this.p = p;
  }

  public String get(String name) {
    return getImpl(p, name, "");
  }

  private static native String getImpl(JavaScriptObject p, String name) /*-{
    return p[name] ? p[name].toString() : p[name] === false ? "false" : null;
  }-*/;

  public int getInt(String name) {
    String val = get(name);
    return val == null ? null : Integer.valueOf(val);
  }

}

}}}