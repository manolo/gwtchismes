Exporting libraries developed using GWT to javascript.

= Introduction =
There are several advantages using GWT to produce quality javascript code, especially the programmer does not have to be an expert in javascript, and don't need to know each browser, packing, obfuscation, units, etc..

The relationship between GWT and javascript is the same as C and assembler. Why code in a low-level language which has different features for each platform when you can work in a high-level language, and leave the compiler to correct mistakes, compile, link, optimise, ofusque, and generate the most appropriate code for each platform.
Also, that you do with C using assembler 'inline', you can put javascript in our java code using [http://code.google.com/webtoolkit/doc/1.6/DevGuideCodingBasics.html # DevGuideJavaScriptNativeInterface JSNI] .

	
= Details =
  * Why the code that GWT generates is not usable from native javascript?. Basically because the process of compilation, renames and creates classes, discards unnecessary stuff, and produces code that is different for each browser and unreadable. In short, the javascript produced behaves just as we want, but does not match the design in our Java application.

  * So, what is the procedure to make calls from a javascript to code generated by GWT?. It is achieved by keeping references in the object browser window. To do this, we need introduce native javascript in our java code that saves the reference using special labels which the compiler will update with the final name of the method.
{{{
 package jschismes.client;
 public class HelloClass implements EntryPoint{
    String prefix = "Hello: ";
    public void onModuleLoad() {
        // Export the method when the application is ready
        exportHelloMethod();
    }
    
    // Method that we ant to use from javascript 
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
    
    // It is only used to create the reference to the real method in the browser
    private native void exportHelloMethod() /*-{
      $wnd.hello: function(param1, param2) {
         return this.@jschismes.client.HelloClass::helloMethod(Ljava/lang/String;) (name);
      };
    }-*/;
 }
}}}
 HTML code
{{{
  <script language='javascript'>
    window.hello("Manolo");
  </script>
}}}

  * Is it possible to simplify this process?. Of course it is, just use the library [http://code.google.com/p/gwt-exporter/ GWT-exporter]. Importing it and making annotations in our java code, the compiler will generate all the necessary code to populate our classes and methods in the object window.
{{{
 package jschismes.client;
 @Export
 public class HelloClass implements Exportable {
    String prefix = "Hello: ";
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
 }
}}}
 HTML code
{{{
  <script language='javascript'>
    var hello = new jschismes.client.HelloClass();
    hello.helloMethod("Manuel");
    window.hello("Manolo");
  </script>
}}}

= Using GWT-exporter = 
  # Only classes that implements 'Exportable' and annotated with @Export will be exported, and only their public methods will be  available. By default GWT-exporter put our classes in the object window under the name-space of the package, in this case window.jschismes.client, but it can be changed using the annotation @Exportpackage.
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public void show(){
  }
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.show();
  </script>
}}}
  # Inherited classes and their public methods are not exported by default, unless they are specifically annotated. Even so, it will be necessary to implement the interface 'Exportable'. The annotation @Export accepts an optional argument to change the name of the exported method.
{{{
package gwtchismes.client;
public class GWTCDatePickerAbstract implements Exportable {
  @Export("foo")
  public void initialise(){
  }
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.show();
     picker.foo();
  </script>
}}}
  # In the entry point of our application will be necessary to notify to GWT which classes we want to export. Exportable classes used as arguments or return in application's methods will be exported automatically.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(DatePicker.class)).export();
  }
}
}}}
  # Also in the entry point, and because our library takes a while to be loaded, it is convenient to invoke a call-back javascript function.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;
}
}}}
{{{
  <script language='javascript'>
    function jscOnLoad() {
        var picker = new jsc.DatePicker();
        picker.show();
    }
  </script>
}}}
  # The arguments and returns of functions must use primitive types or objects which are marked as exportable.
{{{
@Export
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public String show(boolean a1, char a2, int a3, long a4, double a5, myClass a6){
  }
}
}}}
{{{
@Export
public class myClass implements Exportable {
}
}}}
  # To pass javascript functions as arguments to our methods, use the annotation @ExportClosure and create an interface with the public methods you want to export. These methods will have the same arguments and types that the javascript function.
{{{
@Export
@ExportPackage("jsc")
@ExportClosure
public interface JsClosure extends Exportable {
  public void execute(String par1, String par2);
}
}}}
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  public executeJsClosure(JsClosure closure){
     closure.execute("Hello", "Friend");
  }
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.executeJsClosure(function(arg1, arg2) {
        alert(arg1 + "," + arg2);
     });
  </script>
}}}
  # For objects that are implemented in Javascript and in GWT, they will need 'JSNI bridges. A clear example is the Date object that has a different implementation although the behaviour is similar.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  Date currentDate = new Date();
  public JavaScriptObject getCurrentDate(){
     return timeToJsObject(currentDate.getTime());
  }
  public void setCurrentDate(JavaScriptObject date){
     currentDate = new Date(jsObjectToTime(date));
  }

  private static native JavaScriptObject timeToJsObject(double time) /*-{
    return new Date(time);
  }-*/;
  private static native double jsObjectToTime(JavaScriptObject d) /*-{
    return (d && d.getTime) ? d.getTime(): 0;
  }-*/;
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.setCurrentDate(new Date());
     alert(picker.getCurrentDate());
  </script>
}}}
  # Javascript constructors generally accept an object of type 'javascript properties'. Therefore it would be interesting that our classes would accept a javascript properties object as argument in the constructor, being able to extract the configuration you want. This is achieved by creating a class that serves as a bridge between these javascript attributes and GWT.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  String caption = "Select a day";
  int type = 0;
  public DatePicker(JavaScriptObject prop) {
    JsProperties jsProp = new JsProperties(prop);
    this.type = jsProp.getInt("type");
    this.caption = jsProp.get("caption");
  });
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker({
        type: 1,
        caption: "Select a date"
     });
  </script>
}}}
{{{
public class JsProperties {
  JavaScriptObject prop = null;
  JsProperties(JavaScriptObject properties) {
    this.prop = properties;
  }
  public String get(String name) {
    return getImpl(this.prop, name, "");
  }
  public int getInt(String name) {
    String val = get(name);
    return val == null ? null : Integer.valueOf(val);
  }
  private static native String getImpl(JavaScriptObject p, String name) /*-{
    return p[name] ? p[name].toString() : p[name] === false ? "false" : null;
  }-*/;
}
}}}


= GWT module configuration =

 It is recommendable to create a new module to export our GWT library. In fact, it is better not modify our original GWT library, so we could publish it as a .jar file without depending on gwt-exporter. These are the steps to do that:

 # Create a new module and import both, our library and gwt-exporter in the .gwt.xml
{{{
<module>
  <inherits name="com.google.code.p.gwtchismes.GWTChismes"/>
  <inherits name="org.timepedia.exporter.Exporter"/>
</module>
}}}
 # Create so many classes as objects we want to export into javascript. These classes will be the ones that implement the Exportable interface, the ones that use gwt-exporter's annotations, and they have to extend the original classes of our library, publishing a constructor that accepts javascript properties and the methods we want to be available.
{{{
@Export
public class Alert extends GWTCAlert implements Exportable {
  private JsProperties jsProp;
  public Alert(JavaScriptObject prop) {
    super();
    this.jsProp = new JsProperties(prop);
    if (jsProp.defined("className"))
      super.setStyleName(jsProp.get("className"));
  }
  public void show(int seconds) {
    super.show(seconds);
  }
  public void alert(String msg) {
    super.alert(msg);
  }
  public void hide() {
    super.hide();
  }
}
}}}
 # Create an entry-point which notifies GWT which classes to export, and executes the call-back function.
{{{
<module>
  [...]
  <entry-point class="jschismes.client.JsChismes"/>
</module>
}}}
{{{
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(Alert.class)).export();
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;

}}}
 # Compile the module using the cross-site linker, so the produced library could be hosted in any domain or in any CDN server.

Note: GWT 1.6.x & 1.7.0 so far, don't support xs linker in hosted mode, so you have to comment this line just in development time, or you can create another .gwt.xml file for this purpouse. 
{{{
<module>
  [...]
  <add-linker name="xs"/>
</module>
}}}

----
_©2009 Manolo Carrasco Moñino_ 




