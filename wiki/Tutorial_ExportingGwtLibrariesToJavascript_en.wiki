Exporting libraries developed in GWT to javascript.

 * [http://code.google.com/p/gwtchismes/wiki/Tutorial_ExportingGwtLibrariesToJavascript_es Spanish version of this article]
<wiki:toc max_depth="3" />

= Introduction =

There are several advantages to using GWT to produce high quality javascript code. For instance, the programmer does not need to be an expert in javascript, nor know peculiarities of each browser, or spend time packing, compressing, obfuscating, calculating dependencies, etc. And also, there are many advantages in publishing your library not only in java but in javascript, mainly because developers using other languages and frameworks, can take advantage of it without knowing anything about java and gwt.

The relationship between GWT and javascript is the same than C and assembler. Why do you code in a low-level language which has different features for each platform, when you could do it in a high-level language, and give the compiler the responsibility of warning about mistakes, linking, optimising, obfuscating, and generating the most appropriate code for each platform?. Also, just as you can do with C inlining assembler, you can put javascript in your java code using [http://code.google.com/webtoolkit/doc/latest/DevGuideCodingBasicsJSNI.html JSNI].

	
= The Basics =
  * Why is the code that GWT generates not usable from native javascript?. Basically because the process of compilation, renames and creates classes and methods, discards unnecessary things, and produces code that is different for each browser and not readable at all. In short, the javascript produced behaves just as we want, but does not match the design in our original Java application.

  * So, what is the procedure to make calls from javascript to the code generated by GWT?. It is achieved by keeping references in the browser's windows object. To do this, we need to introduce native javascript in our java code that saves the reference using special labels which the compiler will be able to understand and will update with the final and obfuscated name of the method.
{{{
 public class HelloClass implements EntryPoint{
    String prefix = "Hello: ";
    public void onModuleLoad() {
        // Export the method when the application is ready
        exportHelloMethod(this);
    }
    
    // Method that we want to use from javascript 
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
    
    // It is only used to create a reference in the browser to the final method
    private native void exportHelloMethod(HelloClass instance) /*-{
      $wnd.hello = function(name) {
         return instance.@jschismes.client.HelloClass::helloMethod(Ljava/lang/String;) (name);
      };
    }-*/;
 }
}}}
 HTML code
{{{
  <script language='javascript'>
    window.hello("Manolo");
  </script>
}}}

  * Is it possible to simplify this process?. Of course, just use the  [http://code.google.com/p/gwt-exporter/ gwt-exporter] library, import it and make annotations in your java code, then the compiler will generate all the necessary code to populate your classes and methods in the object window.
{{{
 package jschismes.client;
 @Export
 public class HelloClass implements Exportable {
    String prefix = "Hello: ";
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
 }
}}}
 HTML code
{{{
  <script language='javascript'>
    var hello = new jschismes.client.HelloClass();
    hello.helloMethod("Manuel");
  </script>
}}}

= Using GWT-exporter = 
  # Only classes that implement `Exportable` and are annotated with `@Export` will be exported, and only their public methods will be  available. By default gwt-exporter puts our classes in the object window under the package's name-space, but it can be changed using the annotation `@ExportPackage`.
{{{
package jschismes.client;
@ExportPackage("jsc")
@Export
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public void show(){
  }
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.show();
  </script>
}}}
  # Inherited classes and their public methods are not exported by default, unless they are specifically annotated with `@Export`. Even so, it will be necessary to implement the `Exportable` interface. Additionally, `@Export` annotation accepts an optional argument to change the name of the exported method.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public void show(){
  }
}
}}}
{{{
public class GWTCDatePickerAbstract implements Exportable {
  @Export("foo")
  public void initialise(){
  }
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.show();
     picker.foo();
  </script>
}}}
  # In the entry-point of our application it will be necessary to specify which classes we want to export. However, exportable classes used as arguments or returned in application's methods will be exported automatically.
{{{
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(DatePicker.class)).export();
  }
}
}}}
  # Also, in the entry-point we have to invoke a javascript call-back function, so as our library will be available after the entire document is loaded.
{{{
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;
}
}}}
{{{
  <script language='javascript'>
    function jscOnLoad() {
        var picker = new jsc.DatePicker();
        picker.show();
    }
  </script>
}}}
  # The arguments and return values of functions must use primitive types or objects which are marked as `Exportable`.
{{{
@Export
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public String show(boolean a1, char a2, int a3, long a4, double a5, myClass a6){
  }
}
}}}
{{{
@Export
public class myClass implements Exportable {
}
}}}
  # To pass javascript functions as arguments, use the annotation `@ExportClosure` and create an interface with the public methods you want to export. These methods will receive the same arguments and types as the javascript function.
{{{
@Export
@ExportPackage("jsc")
@ExportClosure
public interface JsClosure extends Exportable {
  public void execute(String par1, String par2);
}
}}}
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  public executeJsClosure(JsClosure closure){
     closure.execute("Hello", "Friend");
  }
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.executeJsClosure(function(arg1, arg2) {
        alert(arg1 + "," + arg2);
     });
  </script>
}}}
  # For objects that are implemented in both Javascript and GWT worlds, we need '_JSNI bridges_'. An example of this, is the Date object which has different implementations, although the behaviours are similar.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  Date currentDate = new Date();
  public JavaScriptObject getCurrentDate(){
     return timeToJsObject(currentDate.getTime());
  }
  public void setCurrentDate(JavaScriptObject date){
     currentDate = new Date(jsObjectToTime(date));
  }

  private static native JavaScriptObject timeToJsObject(double time) /*-{
    return new Date(time);
  }-*/;
  private static native double jsObjectToTime(JavaScriptObject d) /*-{
    return (d && d.getTime) ? d.getTime(): 0;
  }-*/;
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.setCurrentDate(new Date());
     alert(picker.getCurrentDate());
  </script>
}}}
  # Javascript constructors generally accept an object of type '_javascript properties_' as argument. Therefore, it would be interesting if our classes could accept a javascript properties' object as argument in the constructor, being able to extract the configuration you want. This is achieved by creating a class that serves as a bridge between these javascript attributes and GWT.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  String caption = "Make your selection";
  int type = 0;
  public DatePicker(JavaScriptObject prop) {
    JsProperties jsProp = new JsProperties(prop);
    this.type = jsProp.getInt("type");
    this.caption = jsProp.get("caption");
  });
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker({
        type: 1,
        caption: "Select a date"
     });
  </script>
}}}
{{{
public class JsProperties {
  JavaScriptObject prop = null;
  JsProperties(JavaScriptObject properties) {
    this.prop = properties;
  }
  public String get(String name) {
    return getImpl(this.prop, name);
  }
  public int getInt(String name) {
    String val = get(name);
    return val == null ? 0 : Integer.valueOf(val);
  }
  private static native String getImpl(JavaScriptObject p, String name) /*-{
    return p[name] ? p[name].toString() : p[name] === false ? "false" : null;
  }-*/;
}
}}}

= Creating and configuring the GWT module to export =

 It is recommended that you create a new module to export your GWT library. In fact, it is better not modify your original GWT library, so you can publish it as a _'.jar'_ file without depending on gwt-exporter. These are the steps to do that:

 # Create a new module and import both, your library and gwt-exporter in the '_.gwt.xml_', and set the property export to '_yes_'
{{{
<module>
  <inherits name="com.google.code.p.gwtchismes.GWTChismes"/>
  <inherits name="org.timepedia.exporter.Exporter"/>
  <set-porperty name="export" value="yes"/>
</module>
}}}
 # Create as many classes as objects that you want to export into javascript. These classes will implement the `Exportable` interface, will use gwt-exporter's annotations, and will have to extend the original classes of your gwt library, publishing a constructor that accepts '_javascript properties_', and the public methods you want to be available from javascript.
{{{
@Export
public class Alert extends GWTCAlert implements Exportable {
  private JsProperties jsProp;
  public Alert(JavaScriptObject prop) {
    super();
    this.jsProp = new JsProperties(prop);
    if (jsProp.defined("className"))
      super.setStyleName(jsProp.get("className"));
  }
  public void show(int seconds) {
    super.show(seconds);
  }
  public void alert(String msg) {
    super.alert(msg);
  }
  public void hide() {
    super.hide();
  }
}
}}}
 # Create an entry-point which notifies GWT which classes to export, and executes the call-back function.
{{{
<module>
  [...]
  <entry-point class="jschismes.client.JsChismes"/>
</module>
}}}
{{{
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(Alert.class)).export();
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;

}}}
 # Compile the module using the cross-site linker, so the produced library could be hosted in any domain or in any CDN server.
{{{
<module>
  [...]
  <add-linker name="xs"/>
</module>
}}}

Note: So far GWT 1.6.x & 1.7.0 don't support xs linker in hosted mode, so you have to comment this line at development time, or you can create another _.gwt.xml_ file for this purpose. 

= Documenting the produced Library = 

Unless java packages that can be easily used letting the java IDE make suggestions about the classes, methods, parameters, etc, to make use of a javascript library it is necessary to have a little documentation about the usage of it. So, don't forget to create and maintain the appropriate documentation of your library. 

Unfortunately there isn't any tool to produce this documentation automatically, but you can document your library in the java code using some proprietary conventions, and then create your own parser to produce a wiki markup page. I use this technique and a home-brewed ugly [http://code.google.com/p/gwtupload/source/browse/trunk/GWTUpload/gjslib.pl perl script] to do that.

= References and examples =
 * [http://code.google.com/p/gwt-exporter Gwt-exporter] library is no documented at all, you have to read the [http://code.google.com/p/gwt-exporter/source/browse/#svn/trunk/samples/src/exporterdemo/client sample code] and its comments to learn how to use it. 
 * [http://code.google.com/p/gwtchismes Gwtchismes] was the first gwt library I exported using this method. It's javascript version its called Jschismes, and here you have the [http://code.google.com/p/gwtchismes/wiki/JsChismes_Documentation documentation], [http://code.google.com/p/gwtchismes/source/browse/#svn/trunk/GWTChismes/src/jschismes/client source code] and [http://gwtchismes.googlecode.com/svn/trunk/website/jslib/JsChismes.html live sample].
 * [http://code.google.com/p/gwtupload/ Gwtupload] is another library I've exported whith the name of Jsupload. You can take a look to the [http://gwtupload.alcala.org/gupld/jsupload/JsUpload.html example], the [http://code.google.com/p/gwtupload/wiki/JsUpload_Documentation documentation] and the [http://code.google.com/p/gwtupload/source/browse/#svn/trunk/GwtUpload/jsupload/src/main/java/jsupload/client code].  

----
_©2009 [http://manolocarrasco.blogspot.com/2009/07/gwtupload-released.html Manolo Carrasco Moñino]_ 