Exporting libraries developed in GWT to javascript.

= Introduction =

There are several advantages using GWT to produce high quality javascript code. For instance, the programmer does not need to be an expert in javascript, to know peculiarities of each browser, or spent time about packing, compressing, obfuscating, calculating dependencies, etc.

The relationship between GWT and javascript is the same as C and assembler. Why do you code in a low-level language which has different features for each platform, when you could do it in a high-level language, and give the compiler the responsibility of warn about mistakes, link, optimise, obfuscate, and generate the most appropriate code for each platform?. Also, as you can do with C inlining assembler, you can put javascript in our java code using [http://code.google.com/webtoolkit/doc/1.6/DevGuideCodingBasics.html#DevGuideJavaScriptNativeInterface JSNI].

And also, there are many advantages in publishing your library not only in java but in javascript, mainly because developers using other languages and frameworks can take advantage of it without knowing anything about java and gwt.
	
= Details =
  * Why the code that GWT generates is not usable from native javascript?. Basically because the process of compilation, renames and creates classes and methods, discards unnecessary stuff, and produces code that is different for each browser and unreadable at all. In short, the javascript produced behaves just as we want, but does not match the design in our original Java application.

  * So, what is the procedure to make calls from javascript to the code generated by GWT?. It is achieved by keeping references in the browser's windows object. To do this, we need to introduce native javascript in our java code that saves the reference using special labels which the compiler will able to understand and update with the final and obfuscated name of the method.
{{{
 package jschismes.client;
 public class HelloClass implements EntryPoint{
    String prefix = "Hello: ";
    public void onModuleLoad() {
        // Export the method when the application is ready
        exportHelloMethod();
    }
    
    // Method that we ant to use from javascript 
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
    
    // It is only used to create the reference to the real method in the browser
    private native void exportHelloMethod() /*-{
      $wnd.hello: function(param1, param2) {
         return this.@jschismes.client.HelloClass::helloMethod(Ljava/lang/String;) (name);
      };
    }-*/;
 }
}}}
 HTML code
{{{
  <script language='javascript'>
    window.hello("Manolo");
  </script>
}}}

  * Is it possible to simplify this process?. Of course, just use the library [http://code.google.com/p/gwt-exporter/ GWT-exporter]. Importing it and making annotations in our java code, the compiler will generate all the necessary stuff to populate our classes and methods in the object window.
{{{
 package jschismes.client;
 @Export
 public class HelloClass implements Exportable {
    String prefix = "Hello: ";
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
 }
}}}
 HTML code
{{{
  <script language='javascript'>
    var hello = new jschismes.client.HelloClass();
    hello.helloMethod("Manuel");
    window.hello("Manolo");
  </script>
}}}

= Using GWT-exporter = 
  # Only classes that implements 'Exportable' and are annotated with @Export will be exported, and only their public methods will be  available. By default GWT-exporter put our classes in the object window under the package's name-space, but it can be changed using the annotation @Exportpackage.
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public void show(){
  }
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.show();
  </script>
}}}
  # Inherited classes and their public methods are not exported by default, unless they are specifically annotated with @Export. Even so, it will be necessary to implement the interface 'Exportable'. Speaking about the @Export annotation, it accepts an optional argument to change the name of the exported method.
{{{
package gwtchismes.client;
public class GWTCDatePickerAbstract implements Exportable {
  @Export("foo")
  public void initialise(){
  }
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.show();
     picker.foo();
  </script>
}}}
  # In the entry point of our application it will be necessary to specify which classes we want to export. However, exportable classes used as arguments or returned in application's methods will be exported automatically.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(DatePicker.class)).export();
  }
}
}}}
  # Also in the entry point, and because our library will be abailable after all the document is loaded, it is convenient to invoke a call-back javascript function.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;
}
}}}
{{{
  <script language='javascript'>
    function jscOnLoad() {
        var picker = new jsc.DatePicker();
        picker.show();
    }
  </script>
}}}
  # The arguments and return of functions must use primitive types or objects which are marked as exportable.
{{{
@Export
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public String show(boolean a1, char a2, int a3, long a4, double a5, myClass a6){
  }
}
}}}
{{{
@Export
public class myClass implements Exportable {
}
}}}
  # To pass javascript functions as arguments, use the annotation @ExportClosure and create an interface with the public methods you want to export. These methods will receive the same arguments and types that the javascript function.
{{{
@Export
@ExportPackage("jsc")
@ExportClosure
public interface JsClosure extends Exportable {
  public void execute(String par1, String par2);
}
}}}
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  public executeJsClosure(JsClosure closure){
     closure.execute("Hello", "Friend");
  }
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.executeJsClosure(function(arg1, arg2) {
        alert(arg1 + "," + arg2);
     });
  </script>
}}}
  # For objects that are implemented in both Javascript and GWT worlds, we need 'JSNI bridges. An example is the Date object that has different implementations although the behaviour is similar.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  Date currentDate = new Date();
  public JavaScriptObject getCurrentDate(){
     return timeToJsObject(currentDate.getTime());
  }
  public void setCurrentDate(JavaScriptObject date){
     currentDate = new Date(jsObjectToTime(date));
  }

  private static native JavaScriptObject timeToJsObject(double time) /*-{
    return new Date(time);
  }-*/;
  private static native double jsObjectToTime(JavaScriptObject d) /*-{
    return (d && d.getTime) ? d.getTime(): 0;
  }-*/;
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.setCurrentDate(new Date());
     alert(picker.getCurrentDate());
  </script>
}}}
  # Javascript constructors generally accept an object of type 'javascript properties' as argument. Therefore, it would be interesting that our classes would accept a javascript properties object as argument in the constructor, being able to extract the configuration you want. This is achieved by creating a class that serves as a bridge between these javascript attributes and GWT.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  String caption = "Select a day";
  int type = 0;
  public DatePicker(JavaScriptObject prop) {
    JsProperties jsProp = new JsProperties(prop);
    this.type = jsProp.getInt("type");
    this.caption = jsProp.get("caption");
  });
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker({
        type: 1,
        caption: "Select a date"
     });
  </script>
}}}
{{{
public class JsProperties {
  JavaScriptObject prop = null;
  JsProperties(JavaScriptObject properties) {
    this.prop = properties;
  }
  public String get(String name) {
    return getImpl(this.prop, name, "");
  }
  public int getInt(String name) {
    String val = get(name);
    return val == null ? null : Integer.valueOf(val);
  }
  private static native String getImpl(JavaScriptObject p, String name) /*-{
    return p[name] ? p[name].toString() : p[name] === false ? "false" : null;
  }-*/;
}
}}}

= Configuring the GWT module =

 It is recommendable to create a new module to export our GWT library. In fact, it is better not modify our original GWT library, so we can publish it as a .jar file without depending on gwt-exporter. These are the steps to do that:

 # Create a new module and import both, our library and gwt-exporter in the .gwt.xml, and set the property export to 'yes'
{{{
<module>
  <inherits name="com.google.code.p.gwtchismes.GWTChismes"/>
  <inherits name="org.timepedia.exporter.Exporter"/>
  <set-porperty name="export" value="yes"/>
</module>
}}}
 # Create so many classes as objects we want to export into javascript. These classes will be the ones that implement the Exportable interface, that use gwt-exporter's annotations, and they have to extend the original classes of our library, publishing a constructor that accepts javascript properties and the methods we want to be available.
{{{
@Export
public class Alert extends GWTCAlert implements Exportable {
  private JsProperties jsProp;
  public Alert(JavaScriptObject prop) {
    super();
    this.jsProp = new JsProperties(prop);
    if (jsProp.defined("className"))
      super.setStyleName(jsProp.get("className"));
  }
  public void show(int seconds) {
    super.show(seconds);
  }
  public void alert(String msg) {
    super.alert(msg);
  }
  public void hide() {
    super.hide();
  }
}
}}}
 # Create an entry-point which notifies GWT which classes to export, and executes the call-back function.
{{{
<module>
  [...]
  <entry-point class="jschismes.client.JsChismes"/>
</module>
}}}
{{{
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(Alert.class)).export();
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;

}}}
 # Compile the module using the cross-site linker, so the produced library could be hosted in any domain or in any CDN server.
{{{
<module>
  [...]
  <add-linker name="xs"/>
</module>
}}}

Note: So far GWT 1.6.x & 1.7.0 don't support xs linker in hosted mode, so you have to comment this line in development time, or you can create another .gwt.xml file for this purpose. 

= Documenting the Javascript Library = 

Unless java packages that can be easily used letting the java IDE to suggest us about the usage and automatically documented using javadoc tool, to use a javascript library it is necessary to have a little documentation about the usage of classes and methods.

So don't forget to create and maintain this documentation of your library. Take a look to the documentation I've produced for my projects.

Unfortunately there isn't any tool to produce this documentation automatically, but you can document your library in the java code using some propietary conventions, and them you can create your own parser to produce a wiki markup page. I use this technique and an ugly [http://code.google.com/p/gwtupload/source/browse/trunk/GWTUpload/gjslib.pl perl script] to do that.

= References =
 * [http://code.google.com/p/gwt-exporter gwt-exporter] library is no documented at all, you have to read the code and in line comments in the [http://code.google.com/p/gwt-exporter/source/browse/#svn/trunk/samples/src/exporterdemo/client sample code] to learn how to use it. 
 * [http://code.google.com/p/gwtchismes Gwtchismes] was the first gwt library I exported using this method. It's javascript version is published under the name Jschismes. And here you have the [http://code.google.com/p/gwtchismes/wiki/JsChismes_Documentation documentation], [http://code.google.com/p/gwtchismes/source/browse/#svn/trunk/GWTChismes/src/jschismes/client source code] and [http://gwtchismes.googlecode.com/svn/trunk/website/jslib/JsChismes.html live sample].
 * [http://code.google.com/p/gwtupload/ Gwtupload] is another library I've exported whith the name of Jsupload. You can take a look to the [http://gwtupload.alcala.org/gupld/jsupload.JsUpload/JsUpload.html example], the [http://code.google.com/p/gwtupload/wiki/JsUpload_Documentation documentation] and the [http://code.google.com/p/gwtupload/source/browse/#svn/trunk/GWTUpload/src/jsupload/client code].  

----
_©2009 Manolo Carrasco Moñino_ 