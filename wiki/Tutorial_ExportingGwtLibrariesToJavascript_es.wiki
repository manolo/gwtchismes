Exportando librerias desarrolladas en GWT a javascript.

<wiki:toc max_depth="3" />

= Introducción =
Hay numerosas ventajas en usar GWT para desarrollar codigo javascript de calidad, especialmente que el programador no tiene que ser un experto en javascript, conocer particularidaded de cada navegador, empaquetamiento de javascript, ofuscación, dependencias entre librerías, etc.

Comparando, la relación que existe entre GWT y javascript, es la misma que entre el lenguaje C y código ensamblador. ¿Para qué voy a programar en un lenguaje de bajo nivel con caracteristicas distintas para cada plataforma si se puede trabajar en un lenguaje de alto nivel, y dejar al compilador que corrija errores, compile, enlace, optimice, ofusque, y genere el código mas apropiado para cada plataforma?.
Además, al igual que en C se puede usar ensamblador 'inline', en GWT podemos introducir código javascript en nuestro código java utilizando [http://code.google.com/webtoolkit/doc/1.6/DevGuideCodingBasics.html#DevGuideJavaScriptNativeInterface JSNI]. 

I finalmente, tambien existen ventajas en publicar tu libreria tanto en gwt como en javascript. Principalmente porque así se podrán aprovechar desarrolladores que utilicen otros lenguages y frameworks, y que no conozcan nada de java y gwt.

= Detalles =
 * ¿porqué el código que genera GWT no es usable desde javascript nativo?. Básicamente porque en el proceso de compilado,  GWT renombra clases, variables, métodos, descarta todo el codigo innecesario, genera nuevas clases, metodos, etc. En pocas palabras, el codigo js producido se comporta justamente como queremos, pero no se corresponde con el diseño que tenemos en nuestra aplicacion java, ademas es distinto para cada navegador y es ilegible.

 * Entonces, ¿cómo se pueden hacer llamadas desde javascript a codigo generado por GWT?. Se consigue guardando referencias a nuestro codigo javascript en el objeto window del navegador. Para ello, en el código javascript del método nativo que guarda esta referencia, debemos utilizar etiquetas especiales que el compilador actualiza con el nombre final de nuestro método compilado.
{{{
 package jschismes.client;
 public class HelloClass implements EntryPoint{
    String prefix = "Hello: ";
    public void onModuleLoad() {
        // Al cargar la aplicacion, exportamos el metodo
        exportHelloMethod();
    }
    
    // Metodo que queremos usar desde javascript
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
    
    // Solo se usa para crear una referencia a nuestra funcion en el navegador
    private native void exportHelloMethod() /*-{
      $wnd.hello: function(param1, param2) {
         return this.@jschismes.client.HelloClass::helloMethod(Ljava/lang/String;) (name);
      };
    }-*/;
 }
}}}
 Codigo HTML
{{{
  <script language='javascript'>
    window.hello("Manolo");
  </script>
}}}

 * ¿Qué podemos hacer para simplificar este proceso?. Sencillo, usar la libreria [http://code.google.com/p/gwt-exporter/ gwt-exporter]. Con ella y haciendo anotaciones en nuestro código java, el compilador es el que genera todo el codigo para publicar nuestros atributos en el objeto window.
{{{
 package jschismes.client;
 @Export
 public class HelloClass implements Exportable {
    String prefix = "Hello: ";
    public String helloMethod(String name) {
        return prefix + " " + name;
    }
 }
}}}
 Código HTML
{{{
  <script language='javascript'>
    var hello = new jschismes.client.HelloClass();
    hello.helloMethod("Manuel");
    window.hello("Manolo");
  </script>
}}}

= Usando gwt-exporter =
 # Sólo las clases anotadas como @Export y que implementan 'Exportable' seran procesadas, y sólo sus métodos públicos estaran disponibles. Por defecto gwt-exporter pondrá nuestras clases en el objeto window bajo el name-space del paquete de nuestra aplicación, en nuestro caso seria window.jschismes.client, pero se puede modificar usando la anotación @Exportpackage.
{{{
package jschismes.client;

@Export
@ExportPackage("jsc")
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public void show(){
  }
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.show();
  </script>
}}}
 # Las clases heredadas, y sus métodos públicos no se exportan a no ser que se anoten especificamente. Aun así será necesario que implementen el interfaz 'Exportable'. La anotación  @Export permite publicar el metodo con otro nombre.
{{{
package gwtchismes.client;
public class GWTCDatePickerAbstract implements Exportable {
  @Export("foo")
  public void initialise(){
  }
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.show();
     picker.foo();
  </script>
}}}
 # En el punto de entrada de nuestra aplicación será necesario decir a GWT qué clases queremos exportar. Las clases exportables que se usen en la aplicacion como argumentos o retornos de otras se exportarán automáticamente.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(DatePicker.class)).export();
  }
}
}}}
 # También en este punto de entrada, y debido a que nuestra libreria tarda un tiempo en estar disponible, es conveniente hacer una llamada a un metodo javascript que la use.
{{{
package gwtchismes.client;
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;
}
}}}
{{{
  <script language='javascript'>
    function jscOnLoad() {
        var picker = new jsc.DatePicker();
        picker.show();
    }
  </script>
}}}
 # Los argumentos y retornos de funcion deben utilizar tipos primitivos u Objetos que se hayan anotado como  @Export.
{{{
@Export
public class DatePicker extends GWTCDatePickerAbstract implements Exportable {
  public String show(boolean a1, char a2, int a3, long a4, double a5, myClass a6){
  }
}
}}}
{{{
@Export
public class myClass implements Exportable {
}
}}}
 # Para pasar funciones javascript como argumentos a nuestros métodos, hay que utilizar la anotacion @ExportClosure y crear un interface con los metodos publicos que queramos exportar. Estos metodos reciben los mismos argumentos y tipos que los de la funcion javascript.
{{{
@Export
@ExportPackage("jsc")
@ExportClosure
public interface JsClosure extends Exportable {
  public void execute(String par1, String par2);
}
}}}
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  public executeJsClosure(JsClosure closure){
     closure.execute("Hello", "Friend");
  }
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.executeJsClosure(function(arg1, arg2) {
        alert(arg1 + "," + arg2);
     });
  </script>
}}}
 # Hay objetos que pueden estar implementados tanto en Javascript como en GWT, para ellos será necesario desarrollar 'JSNI bridges'. Un claro ejemplo es el objeto Date que tiene distinta implementación aunque el comportamiento sea similar.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  Date currentDate = new Date();
  public JavaScriptObject getCurrentDate(){
     return timeToJsObject(currentDate.getTime());
  }
  public void setCurrentDate(JavaScriptObject date){
     currentDate = new Date(jsObjectToTime(date));
  }

  private static native JavaScriptObject timeToJsObject(double time) /*-{
    return new Date(time);
  }-*/;
  private static native double jsObjectToTime(JavaScriptObject d) /*-{
    return (d && d.getTime) ? d.getTime(): 0;
  }-*/;
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker();
     picker.setCurrentDate(new Date());
     alert(picker.getCurrentDate());
  </script>
}}}
 # Los constructores de objetos en javascript generalmente aceptan un objeto de tipo 'javascript properties'. Por tanto será interesante que nuestras clases acepten un objeto javascript y ser capaz de extraer la configuración que el usuario quiere. Esto se consigue creando una clase que sirva de puente entre estos atributos javascript y GWT.
{{{
@Export
@ExportPackage("jsc")
public class DatePicker implements Exportable {
  String caption = "Select a day";
  int type = 0;
  public DatePicker(JavaScriptObject prop) {
    JsProperties jsProp = new JsProperties(prop);
    this.type = jsProp.getInt("type");
    this.caption = jsProp.get("caption");
  });
}
}}}
{{{
  <script language='javascript'>
     var picker = new jsc.DatePicker({
        type: 1,
        caption: "Seleccione fecha"
     });
  </script>
}}}
{{{
public class JsProperties {
  JavaScriptObject prop = null;
  JsProperties(JavaScriptObject properties) {
    this.prop = properties;
  }
  public String get(String name) {
    return getImpl(this.prop, name, "");
  }
  public int getInt(String name) {
    String val = get(name);
    return val == null ? null : Integer.valueOf(val);
  }
  private static native String getImpl(JavaScriptObject p, String name) /*-{
    return p[name] ? p[name].toString() : p[name] === false ? "false" : null;
  }-*/;
}
}}}

= Configuración del módulo GWT =

 Es conveniente generar un nuevo módulo para exportar nuestra librería. De hecho es mejor no modificar nuestra librería original gwt sino usarla en nuestro nuevo módulo, de esta manera la libreria gwt publicada no dependerá de gwt-exporter. Los pasos para hacer esto son:

 # Crear un nuevo módulo e importar nuestra libreria y la libreria gwt-exporter en el fichero .gwt.xml, y establecer la variable export a 'true'
{{{
<module>
  <inherits name="com.google.code.p.gwtchismes.GWTChismes"/>
  <inherits name="org.timepedia.exporter.Exporter"/>
  <set-property name="export" value="yes"/>
</module>
}}}
 # Crear tantas clases java como objetos queramos exportar a javascript. Estas clases seran las que implementen el interfaz Exportable, las que usen las anotaciones de gwt-exporter, y extenderán las clases originales y publicando solo los metodos deseados.
{{{
@Export
public class Alert extends GWTCAlert implements Exportable {
  private JsProperties jsProp;
  public Alert(JavaScriptObject prop) {
    super();
    this.jsProp = new JsProperties(prop);
    if (jsProp.defined("className"))
      super.setStyleName(jsProp.get("className"));
  }
  public void show(int seconds) {
    super.show(seconds);
  }
  public void alert(String msg) {
    super.alert(msg);
  }
  public void hide() {
    super.hide();
  }
}
}}}
 # Crear un punto de entrada en nuestro modulo que notifique a GWT qué clases debe exportar, y ejecute una funcion javascript nativa al cargar la librería.
{{{
<module>
  [...]
  <entry-point class="jschismes.client.JsChismes"/>
</module>
}}}
{{{
public class JsChismes implements EntryPoint {
  public void onModuleLoad() {
    ((Exporter) GWT.create(Alert.class)).export();
    onLoadImpl();
  }
  private native void onLoadImpl() /*-{
    if ($wnd.jscOnLoad && typeof $wnd.jscOnLoad == 'function') $wnd.jscOnLoad();
  }-*/;

}}}
 # Compilar nuestro modulo utilizando el linker 'cross-site' de esta manera la libreria javascript podrá residir en un dominio diferente que el de la aplicacion, por ejemplo usar CDN's. 
{{{
<module>
  [...]
  <add-linker name="xs"/>
</module>
}}}

Nota: las versiones 1.6.x y 1.7.0 de momento no soportan el 'linker xs' en modo 'hosted', por lo que tendreis que comentar esta linea cuando useis este modo, o crear otro fichero gwt.xml para desarrollo.

= Documentión de la librería javascript = 

A diferencia de java, donde es fácil adivinar qué clases, métodos y argumentos usar al usar una libreria en un IDE, en javascript es necesario tener una pequeña documentación que nos indique su uso.

Dicho esto, no olvides crear y mantener la documentación de tu librería javascript.

Desafortunadamente, no hay ninguna utilidad que genere esta documentación automáticamente, pero siempre podrás crearte tus propias convenciones para anotar tu código java y crear tu propio script para generar una pagina de texto com marcas wiki. Yo he usado esta técnica en mis proyectos, y utilizo un [http://code.google.com/p/gwtupload/source/browse/trunk/GWTUpload/gjslib.pl perl script casero] para ello.

= Referencias y ejemplos =
 * La libreria [http://code.google.com/p/gwt-exporter Gwt-exporter] no está documentada en absoluto y es necesario echar un vistazo al código y comentarios del [http://code.google.com/p/gwt-exporter/source/browse/#svn/trunk/samples/src/exporterdemo/client ejemplo] para aprender a usarla.
 * La librería [http://code.google.com/p/gwtchismes Gwtchismes] ha sido la primera librería que he exportado usando esta técnica. La librería producida se llama Jschismes, y aqui puedes ver la [http://code.google.com/p/gwtchismes/wiki/JsChismes_Documentation documentación], [http://code.google.com/p/gwtchismes/source/browse/#svn/trunk/GWTChismes/src/jschismes/client código fuente] y un [http://gwtchismes.googlecode.com/svn/trunk/website/jslib/JsChismes.html ejemplo].
 * [http://code.google.com/p/gwtupload/ Gwtupload] es otra librería que he exportado usando esta técnica. Puedes echar un vistazo al [http://gwtupload.alcala.org/gupld/jsupload.JsUpload/JsUpload.html ejemplo], la [http://code.google.com/p/gwtupload/wiki/JsUpload_Documentation documentación] y el [http://code.google.com/p/gwtupload/source/browse/#svn/trunk/GWTUpload/src/jsupload/client código].  

----
_©2009 Manolo Carrasco Moñino_ 